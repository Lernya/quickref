<!DOCTYPE html>
<html lang="de" data-theme="garden">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/daisyui@latest"></script>
    <link rel="stylesheet" href="src/quickref-classic.css" />

    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism.min.css"
      rel="stylesheet"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/prism.min.js"></script>

    <script type="module">
      import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs";
      mermaid.initialize({ startOnLoad: true });
    </script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              "farbe-lila": "#5F259F", // Beispiel benutzerdefinierte Farbe
            },
          },
          plugins: [daisyui],
        },
      };
    </script>
    <style>
      /* Hier kann unsere TailwindCSS-Konfiguration hin. (Auch die obige tailwind.config laesst sich (fast) wie gewohnt ausbauen) */
    </style>
    <title>Quickref</title>
  </head>
  <body>
    <header
      class="flex items-center gap-8 px-8 md:px-16 lg:px-32 py-4 bg-[#F7F9FE]"
    >
      <figure class="w-14 h-auto">
        <img class="w-full h-full" src="img/header_icon.svg" alt="" />
      </figure>
      <h1 class="font-sans text-[#8A9BBC] text-4xl">React cheatsheet</h1>
      <nav></nav>
    </header>

    <main class="mt-8 p-4">
      <!-- <h1 class="text-4xl font-extrabold">Quickref</h1> -->

      <section></section>

      <section></section>

      <section></section>

      <section class="flex flex-col gap-4 px-8 md:px-16 lg:px-32 max-w-6xl">
        <div class="router">


          <section>
            <h1 class="text-2xl font-bold">React Router</h1>
    
            <section>
              <h1 class="text-xl mt-5">Key concept:</h1>
              <p>React Router is all about matching the URL to the paths specified in the React Router Objects. That means, if the URL changes, e.g. due to a user interaction, React Router tries to match the URL to the routes for rendering the nested react components.</p>
            </section>
    
            <div class="section">
              <h2 class="text-xl">1. Basic Setup</h2>
              <p>Install <code>react-router-dom</code>:</p>
              <div class="mockup-code">
                <pre><code>npm install react-router-dom</code></pre>
              </div>
              <p>Wrap your app in <code>&lt;BrowserRouter&gt;</code>:</p>
              <div class="mockup-code">
                <pre><code>
              import { BrowserRouter as Router, Route, Routes } from &#39;react-router-dom&#39;;
              
              function App() {
                return (
                  &lt;Router&gt;
                    &lt;Routes&gt;
                      &lt;Route path=&quot;/&quot; element={&lt;Home /&gt;} /&gt;
                      &lt;Route path=&quot;/about&quot; element={&lt;About /&gt;} /&gt;
                    &lt;/Routes&gt;
                  &lt;/Router&gt;
                );
              }
                    </code></pre>
              </div>
            </div>
    
    
            <div class="section">
              <h2 class="text-xl">2. Navigation</h2>
              <!-- <p>Define routes with <code>&lt;Routes&gt;</code> and <code>&lt;Route&gt;</code>:</p>
                  <div class="mockup-code">
                    <pre><code>
              import { Routes, Route } from &#39;react-router-dom&#39;;
              
              function App() {
                return (
                  &lt;Routes&gt;
                    &lt;Route path=&quot;/&quot; element={&lt;Home /&gt;} /&gt;
                    &lt;Route path=&quot;/about&quot; element={&lt;About /&gt;} /&gt;
                  &lt;/Routes&gt;
                );
              }
                    </code></pre>
                  </div> -->
              <p>Navigate between routes using <code>&lt;Link&gt;</code> or <code>&lt;NavLink&gt;</code>.
                The latter provides transition properties e.g. "active" / "pending". <a class="link"
                  href="https://reactrouter.com/en/main/components/nav-link">(More on NavLink)</a></p>
              <div class="mockup-code">
                <pre><code>
              import { Link } from &#39;react-router-dom&#39;;
              
              function Navbar() {
                return (
                  &lt;nav&gt;
                    &lt;Link to=&quot;/&quot;&gt;Home&lt;/Link&gt;
                    &lt;Link to=&quot;/about&quot;&gt;About&lt;/Link&gt;
                  &lt;/nav&gt;
                );
              }
                    </code></pre>
              </div>
            </div>
    
    
            <div class="section">
              <h2 class="text-xl">3. Dynamic Routes</h2>
              <p>Segments of the URL can be dynamic placeholders. React router tries to match the URL with the specified
                placeholder in the Route</p>
              <div class="mockup-code">
                <pre><code>
              import { Routes, Route, useParams } from &#39;react-router-dom&#39;;
              
              function Product() {
                const { id } = useParams();
                return &lt;div&gt;Product ID: {id}&lt;/div&gt;;
              }
              
              function App() {
                return (
                  &lt;Routes&gt;
                    &lt;Route path=&quot;/product/:id&quot; element={&lt;Product /&gt;} /&gt;
                  &lt;/Routes&gt;
                );
              }
                    </code></pre>
              </div>
            </div>
    
    
            <div class="section">
              <h2 class="text-xl">4. Nested Routes and Outlet</h2>
              <p>Outlet is used to render the child route elements of the parent route element</p>
              <div class="mockup-code">
                <pre><code>
              import { Routes, Route, Outlet } from &#39;react-router-dom&#39;;
              
              function Dashboard() {
                return (
                  &lt;div&gt;
                    &lt;h2&gt;Dashboard&lt;/h2&gt;
                    &lt;Outlet /&gt;
                  &lt;/div&gt;
                );
              }
              
              function App() {
                return (
                  &lt;Routes&gt;
                    &lt;Route path=&quot;/dashboard&quot; element={&lt;Dashboard /&gt;}&gt;
                      &lt;Route path=&quot;analytics&quot; element={&lt;Analytics /&gt;} /&gt;
                      &lt;Route path=&quot;reports&quot; element={&lt;Reports /&gt;} /&gt;
                    &lt;/Route&gt;
                  &lt;/Routes&gt;
                );
              }
                    </code></pre>
              </div>
            </div>
    
    
    
            <div class="section">
              <h2 class="text-xl">5. Protected Routes</h2>
              <p>Use a wrapper component to protect routes that require authentication.</p>
              <p>The <code>isAuthenticated</code> function checks if the user is authenticated.
                The <code>ProtectedRoute</code> component renders the protected component if the user is authenticated, or
                redirects them to the login page if not.
              </p>
              <div class="mockup-code">
                <pre><code>
              // Authentication service (dummy)
              const isAuthenticated = () =&gt; {
                return localStorage.getItem(&#39;authToken&#39;) ? true : false;
              }
              
              // ProtectedRoute component
              import { Navigate } from &#39;react-router-dom&#39;;
              
              function ProtectedRoute({ element }) {
                return isAuthenticated() ? element : &lt;Navigate to=&quot;/login&quot; /&gt;;
              }
              
              // Usage in App
              function App() {
                return (
                  &lt;Routes&gt;
                    &lt;Route path=&quot;/login&quot; element={&lt;Login /&gt;} /&gt;
                    &lt;Route path=&quot;/dashboard&quot; element={&lt;ProtectedRoute element={&lt;Dashboard /&gt;} /&gt;} /&gt;
                  &lt;/Routes&gt;
                );
              }
                    </code></pre>
              </div>
    
            </div>
    
    
            <div class="section">
              <h2 class="text-xl">6. Navigation</h2>
              <p>The <code>useNavigate</code> hook returns a function that lets you navigate programmatically:</p>
              <div class="mockup-code">
                <pre><code>
              import { useNavigate } from &#39;react-router-dom&#39;;
              
              function Login() {
                const navigate = useNavigate();
              
                const handleLogin = () =&gt; {
                  // Perform login logic
                  navigate(&#39;/dashboard&#39;);
                }
              
                return (
                  &lt;button onClick={handleLogin}&gt;Login&lt;/button&gt;
                );
              }
                    </code></pre>
              </div>
            </div>
          </section>
        </div>
      </section>

      <!-- form section -->
      <section class="flex flex-col gap-4 px-8 md:px-16 lg:px-32 max-w-6xl">
        <h2 class="text-2xl font-bold">Forms in React</h2>
        <!-- about useState in forms -->
        <p class="text-lg">
          In React, mutable state is typically kept in the state property of
          components, and only updated with
          <span class="text-red-500">setState()</span>.
        </p>
        <pre
          class="bg-black text-white rounded"
        ><code class="language-javascript">
        const [formData, setFormData] = useState({
          email: "",
          password: "",
        });
        </code></pre>
        <hr class="solid" />
        <!-- about changes form data -->
        <p class="text-lg">
          Since the value attribute is set on our form element, the displayed
          value will always be this.state.value, making the React state the
          source of truth. Since handleChange runs on every keystroke to update
          the React state, the displayed value will update as the user types.
        </p>
        <pre
          class="bg-black text-white rounded"
        ><code class="language-javascript">
        const handleChange = (e) => {
          const { name, value } = e.target;
          setFormData((prev) => ({
            ...prev,
            [name]: value,
          }));
        };
        </code></pre>
        <p class="text-lg">
          The whole expression
          <span class="text-red-500"
            >{ ...prev, [e.target.name]: e.target.value }</span
          >
          returns a new object. This new object has all the properties of
          <span class="text-red-500">prev</span> but with the key matching
          <span class="text-red-500">e.target.name</span> updated to
          <span class="text-red-500">e.target.value</span>.
        </p>
        <hr class="solid" />
        <!-- about validation -->
        <p class="text-lg">
          This validation function checks the validity of formData.email and
          formData.password against predefined regular expressions, it ensures
          that the email format and password length meet specific criteria. If
          any of these criteria are not met, the function updates the error
          state using setErrors, marking the form as invalid. This process
          allows real-time validation feedback, with the form only being
          considered valid if all checks pass.
        </p>
        <pre
          class="bg-black text-white rounded"
        ><code class="language-javascript">
        const validate = () => {
          let isValid = true;
          const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
          const passRegex = /^.{8,}$/;

          if (!emailRegex.test(formData.email)) {
            setErrors((prev) => ({
              ...prev,
              emailError: "Invalid Email",
            }));
            isValid = false;
          }

          if (!passRegex.test(formData.password)) {
            setErrors((prev) => ({
              ...prev,
              passError: "Password must be at least 8 characters.",
            }));
            isValid = false;
          }
          return isValid;
        };
        </code></pre>
      </section>
    </main>
  </body>
</html>
